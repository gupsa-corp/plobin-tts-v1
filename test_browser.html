<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¸Œë¼ìš°ì € í…ŒìŠ¤íŠ¸ - ìŒì„± ëŒ€í™” ì‹œìŠ¤í…œ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .btn:hover { background: #0056b3; }
        .btn:disabled { background: #6c757d; cursor: not-allowed; }
        .log {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .error { color: #dc3545; }
        .success { color: #28a745; }
        .info { color: #17a2b8; }
    </style>
</head>
<body>
    <h1>ğŸ”§ ìŒì„± ëŒ€í™” ì‹œìŠ¤í…œ - ë¸Œë¼ìš°ì € í…ŒìŠ¤íŠ¸</h1>

    <div class="test-section">
        <h2>1. ë¸Œë¼ìš°ì € ì§€ì› í™•ì¸</h2>
        <div id="browser-support">
            <p>MediaDevices API: <span id="mediadevices-support" class="status">í™•ì¸ ì¤‘...</span></p>
            <p>WebSocket API: <span id="websocket-support" class="status">í™•ì¸ ì¤‘...</span></p>
            <p>MediaRecorder API: <span id="mediarecorder-support" class="status">í™•ì¸ ì¤‘...</span></p>
            <p>Web Audio API: <span id="webaudio-support" class="status">í™•ì¸ ì¤‘...</span></p>
        </div>
    </div>

    <div class="test-section">
        <h2>2. ë§ˆì´í¬ ê¶Œí•œ í…ŒìŠ¤íŠ¸</h2>
        <button id="test-microphone" class="btn">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ í…ŒìŠ¤íŠ¸</button>
        <p>ìƒíƒœ: <span id="mic-status" class="status warning">í…ŒìŠ¤íŠ¸ í•„ìš”</span></p>
        <div id="mic-log" class="log"></div>
    </div>

    <div class="test-section">
        <h2>3. WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸</h2>
        <button id="test-websocket" class="btn">ğŸ”Œ WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸</button>
        <p>ìƒíƒœ: <span id="ws-status" class="status warning">í…ŒìŠ¤íŠ¸ í•„ìš”</span></p>
        <div id="ws-log" class="log"></div>
    </div>

    <div class="test-section">
        <h2>4. ì˜¤ë””ì˜¤ ë…¹ìŒ ë° ì „ì†¡ í…ŒìŠ¤íŠ¸</h2>
        <button id="start-recording" class="btn">ğŸ¤ ë…¹ìŒ ì‹œì‘</button>
        <button id="stop-recording" class="btn" disabled>â¹ï¸ ë…¹ìŒ ì¤‘ì§€</button>
        <p>ìƒíƒœ: <span id="recording-status" class="status warning">ì¤€ë¹„</span></p>
        <div id="recording-log" class="log"></div>
    </div>

    <div class="test-section">
        <h2>5. TTS í…ŒìŠ¤íŠ¸</h2>
        <input type="text" id="tts-text" placeholder="í…ŒìŠ¤íŠ¸í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." value="ì•ˆë…•í•˜ì„¸ìš”, TTS í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.">
        <button id="test-tts" class="btn">ğŸ”Š TTS í…ŒìŠ¤íŠ¸</button>
        <p>ìƒíƒœ: <span id="tts-status" class="status warning">í…ŒìŠ¤íŠ¸ í•„ìš”</span></p>
        <div id="tts-log" class="log"></div>
    </div>

    <script>
        class BrowserTester {
            constructor() {
                this.websocket = null;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;

                this.init();
            }

            init() {
                this.checkBrowserSupport();
                this.setupEventListeners();
            }

            log(elementId, message, type = 'info') {
                const logElement = document.getElementById(elementId);
                const timestamp = new Date().toLocaleTimeString();
                const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
                logElement.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
                logElement.scrollTop = logElement.scrollHeight;
            }

            updateStatus(statusId, status, text) {
                const element = document.getElementById(statusId);
                element.className = `status ${status}`;
                element.textContent = text;
            }

            checkBrowserSupport() {
                // MediaDevices API
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    this.updateStatus('mediadevices-support', 'success', 'ì§€ì›ë¨');
                } else {
                    this.updateStatus('mediadevices-support', 'error', 'ì§€ì›ë˜ì§€ ì•ŠìŒ');
                }

                // WebSocket API
                if (typeof WebSocket !== 'undefined') {
                    this.updateStatus('websocket-support', 'success', 'ì§€ì›ë¨');
                } else {
                    this.updateStatus('websocket-support', 'error', 'ì§€ì›ë˜ì§€ ì•ŠìŒ');
                }

                // MediaRecorder API
                if (typeof MediaRecorder !== 'undefined') {
                    this.updateStatus('mediarecorder-support', 'success', 'ì§€ì›ë¨');
                } else {
                    this.updateStatus('mediarecorder-support', 'error', 'ì§€ì›ë˜ì§€ ì•ŠìŒ');
                }

                // Web Audio API
                if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                    this.updateStatus('webaudio-support', 'success', 'ì§€ì›ë¨');
                } else {
                    this.updateStatus('webaudio-support', 'error', 'ì§€ì›ë˜ì§€ ì•ŠìŒ');
                }
            }

            setupEventListeners() {
                document.getElementById('test-microphone').addEventListener('click', () => this.testMicrophone());
                document.getElementById('test-websocket').addEventListener('click', () => this.testWebSocket());
                document.getElementById('start-recording').addEventListener('click', () => this.startRecording());
                document.getElementById('stop-recording').addEventListener('click', () => this.stopRecording());
                document.getElementById('test-tts').addEventListener('click', () => this.testTTS());
            }

            async testMicrophone() {
                this.log('mic-log', 'ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì¤‘...', 'info');

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });

                    this.log('mic-log', 'âœ… ë§ˆì´í¬ ê¶Œí•œ íšë“ ì„±ê³µ!', 'success');
                    this.updateStatus('mic-status', 'success', 'ê¶Œí•œ íšë“ë¨');

                    // ìŠ¤íŠ¸ë¦¼ ì •ë³´ ë¡œê·¸
                    const audioTracks = stream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        const track = audioTracks[0];
                        this.log('mic-log', `ì˜¤ë””ì˜¤ íŠ¸ë™: ${track.label}`, 'info');
                        this.log('mic-log', `ì„¤ì •: ${JSON.stringify(track.getSettings())}`, 'info');
                    }

                    // ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
                    stream.getTracks().forEach(track => track.stop());

                } catch (error) {
                    this.log('mic-log', `âŒ ë§ˆì´í¬ ê¶Œí•œ ì‹¤íŒ¨: ${error.message}`, 'error');
                    this.updateStatus('mic-status', 'error', 'ê¶Œí•œ ê±°ë¶€ë¨');
                }
            }

            async testWebSocket() {
                this.log('ws-log', 'WebSocket ì—°ê²° ì‹œë„...', 'info');

                try {
                    const wsUrl = `ws://${window.location.host}/ws/chat`;
                    this.log('ws-log', `ì—°ê²° URL: ${wsUrl}`, 'info');

                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        this.log('ws-log', 'âœ… WebSocket ì—°ê²° ì„±ê³µ!', 'success');
                        this.updateStatus('ws-status', 'success', 'ì—°ê²°ë¨');

                        // í•‘ í…ŒìŠ¤íŠ¸
                        const pingMessage = {
                            type: 'ping',
                            timestamp: new Date().toISOString()
                        };
                        this.websocket.send(JSON.stringify(pingMessage));
                        this.log('ws-log', 'í•‘ ë©”ì‹œì§€ ì „ì†¡', 'info');
                    };

                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.log('ws-log', `ğŸ“¨ ìˆ˜ì‹ : ${JSON.stringify(data)}`, 'success');
                    };

                    this.websocket.onclose = () => {
                        this.log('ws-log', 'âŒ WebSocket ì—°ê²° ì¢…ë£Œ', 'error');
                        this.updateStatus('ws-status', 'error', 'ì—°ê²° ì¢…ë£Œë¨');
                    };

                    this.websocket.onerror = (error) => {
                        this.log('ws-log', `âŒ WebSocket ì˜¤ë¥˜: ${error}`, 'error');
                        this.updateStatus('ws-status', 'error', 'ì—°ê²° ì˜¤ë¥˜');
                    };

                } catch (error) {
                    this.log('ws-log', `âŒ WebSocket ì—°ê²° ì‹¤íŒ¨: ${error.message}`, 'error');
                    this.updateStatus('ws-status', 'error', 'ì—°ê²° ì‹¤íŒ¨');
                }
            }

            async startRecording() {
                if (this.isRecording) return;

                this.log('recording-log', 'ë…¹ìŒ ì‹œì‘ ì¤€ë¹„...', 'info');

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });

                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });

                    this.audioChunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                            this.log('recording-log', `ë°ì´í„° ì²­í¬: ${event.data.size} bytes`, 'info');
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.processRecording();
                        stream.getTracks().forEach(track => track.stop());
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;

                    document.getElementById('start-recording').disabled = true;
                    document.getElementById('stop-recording').disabled = false;

                    this.log('recording-log', 'âœ… ë…¹ìŒ ì‹œì‘ë¨', 'success');
                    this.updateStatus('recording-status', 'success', 'ë…¹ìŒ ì¤‘');

                } catch (error) {
                    this.log('recording-log', `âŒ ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨: ${error.message}`, 'error');
                    this.updateStatus('recording-status', 'error', 'ë…¹ìŒ ì‹¤íŒ¨');
                }
            }

            stopRecording() {
                if (!this.isRecording || !this.mediaRecorder) return;

                this.mediaRecorder.stop();
                this.isRecording = false;

                document.getElementById('start-recording').disabled = false;
                document.getElementById('stop-recording').disabled = true;

                this.log('recording-log', 'â¹ï¸ ë…¹ìŒ ì¤‘ì§€ë¨', 'info');
                this.updateStatus('recording-status', 'warning', 'ì²˜ë¦¬ ì¤‘');
            }

            async processRecording() {
                if (this.audioChunks.length === 0) {
                    this.log('recording-log', 'âŒ ë…¹ìŒëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤', 'error');
                    return;
                }

                try {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    this.log('recording-log', `ì˜¤ë””ì˜¤ ë¸”ë¡­ ìƒì„±: ${audioBlob.size} bytes`, 'info');

                    // Base64 ë³€í™˜
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const base64Audio = this.arrayBufferToBase64(arrayBuffer);

                    this.log('recording-log', `Base64 ë³€í™˜ ì™„ë£Œ: ${base64Audio.length} chars`, 'info');

                    // WebSocketìœ¼ë¡œ ì „ì†¡
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        const message = {
                            type: 'audio',
                            data: base64Audio,
                            timestamp: new Date().toISOString()
                        };

                        this.websocket.send(JSON.stringify(message));
                        this.log('recording-log', 'ğŸ“¤ ì˜¤ë””ì˜¤ ë°ì´í„° ì „ì†¡ ì™„ë£Œ', 'success');
                        this.updateStatus('recording-status', 'success', 'ì „ì†¡ ì™„ë£Œ');
                    } else {
                        this.log('recording-log', 'âŒ WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
                        this.updateStatus('recording-status', 'error', 'WebSocket ì˜¤ë¥˜');
                    }

                } catch (error) {
                    this.log('recording-log', `âŒ ë…¹ìŒ ì²˜ë¦¬ ì‹¤íŒ¨: ${error.message}`, 'error');
                    this.updateStatus('recording-status', 'error', 'ì²˜ë¦¬ ì‹¤íŒ¨');
                }
            }

            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            async testTTS() {
                const text = document.getElementById('tts-text').value.trim();
                if (!text) {
                    alert('í…ŒìŠ¤íŠ¸í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    return;
                }

                this.log('tts-log', 'TTS ìš”ì²­ ì „ì†¡...', 'info');

                try {
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: text,
                            language: 'KR',
                            speed: 1.0,
                            device: 'auto'
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.log('tts-log', 'âœ… TTS ë³€í™˜ ì„±ê³µ!', 'success');
                        this.log('tts-log', `ì˜¤ë””ì˜¤ URL: ${result.audio_url}`, 'info');
                        this.updateStatus('tts-status', 'success', 'ë³€í™˜ ì„±ê³µ');

                        // ì˜¤ë””ì˜¤ ì¬ìƒ
                        const audio = new Audio(result.audio_url);
                        audio.play();
                        this.log('tts-log', 'ğŸ”Š ì˜¤ë””ì˜¤ ì¬ìƒ ì‹œì‘', 'success');

                    } else {
                        this.log('tts-log', `âŒ TTS ì‹¤íŒ¨: ${result.error}`, 'error');
                        this.updateStatus('tts-status', 'error', 'ë³€í™˜ ì‹¤íŒ¨');
                    }

                } catch (error) {
                    this.log('tts-log', `âŒ TTS ìš”ì²­ ì‹¤íŒ¨: ${error.message}`, 'error');
                    this.updateStatus('tts-status', 'error', 'ìš”ì²­ ì‹¤íŒ¨');
                }
            }
        }

        // í…ŒìŠ¤í„° ì‹œì‘
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸ”§ ë¸Œë¼ìš°ì € í…ŒìŠ¤í„° ì‹œì‘');
            new BrowserTester();
        });
    </script>
</body>
</html>